#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Project Euler Problem 11
#
# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?
#
# By using the multiplication principal or fundamental principal of counting we
# can count the number of divisors of an integer by finding all the prime
# factors and the occurances of those prime factors.
# In general for prime factors a_x of integer n, we can find the number of divisors
# if we count the number of occursances of a_x as a prime factor of n, representing
# that occurance as i_x.
# Therefore, we have nDivisors = (i_1 + 1)(i_2 + 1)(i_3 + 1)...
# For example, the prime factors of 288 can be represented 288 = (2^5)+(3^2)
# where 2 and 3 are the prime factors. Their exponents represent how often
# the prime factors occur for 288. nDivisors(288) = (5+1)(2+1) = 18.
# There are 18 divisors of 288:
# 1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 32, 36, 48, 72, 96, 144, 288. 

import random

_numTrials = 10

triangularNum = 0
i = 0
divisors = []


def isProbablePrime(n):
    assert n >= 2
    # special case 2
    if n == 2:
        return True
    # ensure n is odd
    if n % 2 == 0:
        return False
    # write n-1 as 2**s * d
    # repeatedly try to divide n-1 by 2
    s = 0
    d = n-1
    while True:
        quotient, remainder = divmod(d, 2)
        if remainder == 1:
            break
        s += 1
        d = quotient
    assert(2**s * d == n-1)

    # test the base a to see whether it is a witness for the compositeness of n
    def try_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True # n is definitely composite

    for i in range(_numTrials):
        a = random.randrange(2, n)
        if try_composite(a):
            return False

    return True # no base tested showed n as composite


def getFactors(num):
    secondFactor = 0
    firstFactor = 1

    while(firstFactor < num):
        firstFactor = firstFactor + 1
        if(num % firstFactor == 0):
            secondFactor = num / firstFactor
            return [firstFactor,secondFactor]

#find all the prime factors of an integer n
#returns a list of prime factors
def findPrimeFactors(n):
    primeFactors = []
    while True:
        factors = getFactors(n)
        primeFactors.append(factors[0])
        if isProbablePrime(factors[1]):
            primeFactors.append(factors[1])
            return primeFactors
        n = factors[1]

#returns the number of divisors of given integer n
#assumes n >= 3
def nDivisors(n):
    if(n <= 3):
        return -1
    numDivisors = 1
    primesArray = findPrimeFactors(n)
    while len(primesArray) > 0:
        numDivisors *= (primesArray.count(primesArray[0]) + 1)
        primesArray = [value for value in primesArray if value != primesArray[0]]
    return numDivisors

divisors = 0
while(divisors < 500):
    i += 1
    triangularNum += i
    divisors = nDivisors(triangularNum)

print triangularNum
